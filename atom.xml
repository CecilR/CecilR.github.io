<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://CecilR.github.io</id>
    <title>Timing is Fun</title>
    <updated>2019-12-11T09:18:09.842Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://CecilR.github.io"/>
    <link rel="self" href="https://CecilR.github.io/atom.xml"/>
    <subtitle>一名死磕时序数据的小白</subtitle>
    <logo>https://CecilR.github.io/images/avatar.png</logo>
    <icon>https://CecilR.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Timing is Fun</rights>
    <entry>
        <title type="html"><![CDATA[Deep learning-based Applications in Industrial Process Monitoring - Fault detection]]></title>
        <id>https://CecilR.github.io/post/deep-learning-based-applications-in-industrial-process-monitoring-fault-detection</id>
        <link href="https://CecilR.github.io/post/deep-learning-based-applications-in-industrial-process-monitoring-fault-detection">
        </link>
        <updated>2019-12-11T09:06:42.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://CecilR.github.io/post-images/1576055643782.PNG" alt=""><br>
<img src="https://CecilR.github.io/post-images/1576055648958.PNG" alt=""><br>
<img src="https://CecilR.github.io/post-images/1576055787588.PNG" alt=""><br>
<img src="https://CecilR.github.io/post-images/1576055651911.PNG" alt=""><br>
<img src="https://CecilR.github.io/post-images/1576055657611.PNG" alt=""><br>
<img src="https://CecilR.github.io/post-images/1576055661139.PNG" alt=""><br>
<img src="https://CecilR.github.io/post-images/1576055664131.PNG" alt=""><br>
<img src="https://CecilR.github.io/post-images/1576055667671.PNG" alt=""><br>
<img src="https://CecilR.github.io/post-images/1576055671111.PNG" alt=""><br>
<img src="https://CecilR.github.io/post-images/1576055737569.PNG" alt=""><br>
<img src="https://CecilR.github.io/post-images/1576055742250.PNG" alt=""><br>
<img src="https://CecilR.github.io/post-images/1576055746159.PNG" alt=""><br>
<img src="https://CecilR.github.io/post-images/1576055749184.PNG" alt=""><br>
<img src="https://CecilR.github.io/post-images/1576055753369.PNG" alt=""><br>
<img src="https://CecilR.github.io/post-images/1576055758117.PNG" alt=""><br>
<img src="https://CecilR.github.io/post-images/1576055762404.PNG" alt=""><br>
<img src="https://CecilR.github.io/post-images/1576055766369.PNG" alt=""><br>
<img src="https://CecilR.github.io/post-images/1576055770248.PNG" alt=""><br>
<img src="https://CecilR.github.io/post-images/1576055774485.PNG" alt=""><br>
<img src="https://CecilR.github.io/post-images/1576055778143.PNG" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Deep learning-based Applications in Industrial Process Monitoring - Soft sensor, Quality prediction]]></title>
        <id>https://CecilR.github.io/post/deep-learning-based-applications-in-industrial-process-monitoring-soft-sensor-quality-prediction</id>
        <link href="https://CecilR.github.io/post/deep-learning-based-applications-in-industrial-process-monitoring-soft-sensor-quality-prediction">
        </link>
        <updated>2019-12-11T08:55:36.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://CecilR.github.io/post-images/1576054628861.PNG" alt=""><br>
<img src="https://CecilR.github.io/post-images/1576054720763.PNG" alt=""><br>
<img src="https://CecilR.github.io/post-images/1576054723275.PNG" alt=""><br>
<img src="https://CecilR.github.io/post-images/1576054725797.PNG" alt=""><br>
<img src="https://CecilR.github.io/post-images/1576054728353.PNG" alt=""><br>
<img src="https://CecilR.github.io/post-images/1576054731472.PNG" alt=""><br>
<img src="https://CecilR.github.io/post-images/1576054811232.PNG" alt=""><br>
<img src="https://CecilR.github.io/post-images/1576054820341.PNG" alt=""><br>
<img src="https://CecilR.github.io/post-images/1576054859744.PNG" alt=""><br>
<img src="https://CecilR.github.io/post-images/1576054864646.PNG" alt=""><br>
<img src="https://CecilR.github.io/post-images/1576054869221.PNG" alt=""><br>
<img src="https://CecilR.github.io/post-images/1576054873605.PNG" alt=""><br>
<img src="https://CecilR.github.io/post-images/1576054914689.PNG" alt=""><br>
<img src="https://CecilR.github.io/post-images/1576054919466.PNG" alt=""><br>
<img src="https://CecilR.github.io/post-images/1576054925147.PNG" alt=""><br>
<img src="https://CecilR.github.io/post-images/1576054930628.PNG" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Matplotlib常用绘图指令]]></title>
        <id>https://CecilR.github.io/post/matplotlib-chang-yong-hui-tu-zhi-ling</id>
        <link href="https://CecilR.github.io/post/matplotlib-chang-yong-hui-tu-zhi-ling">
        </link>
        <updated>2019-09-28T13:00:41.000Z</updated>
        <content type="html"><![CDATA[<h2 id="常用配置-matplotlibrcparams">常用配置: matplotlib.rcParams</h2>
<ul>
<li>A dictionary object including validation</li>
</ul>
<pre><code class="language-python">    import matplotlib as mpl
    import matplotlib.pyplot as plt
    %matplotlib inline
    
    mpl.rcParams['font.sans-serifs'] = ['SimHei'] # 中文支持
    mpl.rcParams['axes.unicode_minus'] = False # 正常显示负号
    
    mpl.rcParams['lines.linewidth'] = 5 # 线条宽度
    mpl.rcParams['lines.color'] = 'red' # 线条颜色
    mpl.rcParams['lines.linestyle'] = '-' # 线条样式
</code></pre>
<hr>
<h2 id="基本图形">基本图形</h2>
<h3 id="直方图">直方图</h3>
<ul>
<li>查看分布规律</li>
<li>plt.hist(x, bins)
<ul>
<li>x - array or sequence of (n,) arrays，数据data</li>
<li>bins - int or sequence or str, optional， 横坐标区间</li>
</ul>
</li>
</ul>
<pre><code class="language-python">    import matplotlib.pyplot as plt 
    %matplotlib inline
    
    height = [168, 155, 182, 170, 173, 161]
    bins = range(150,191,5)
    
    plt.hist(height, bins=bins)
    plt.show()
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://CecilR.github.io/post-images/1569675696544.png" alt=""></figure>
<h3 id="条形图">条形图</h3>
<ul>
<li>同类数据进行对比</li>
<li>plt.bar(x, y)</li>
</ul>
<pre><code class="language-python">    import matplotlib.pyplot as plt 
    %matplotlib inline
    
    classes = ['class 1', 'class 2', 'class 3']
    scores = [70, 80, 60]
    
    plt.bar(classes, scores)
    plt.show()
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://CecilR.github.io/post-images/1569675754243.png" alt=""></figure>
<h3 id="折线图">折线图</h3>
<ul>
<li>展示数据随某一指标变化的关系</li>
<li>plt.plot(x, y)</li>
</ul>
<pre><code class="language-python">    import matplotlib.pyplot as plt 
    %matplotlib inline
    
    plt.rcParams['font.sans-serif'] = ['SimHei']
    
    plt.plot(year, height)
    plt.title('身高随时间变化图')
    plt.show()
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://CecilR.github.io/post-images/1569675782251.png" alt=""></figure>
<h3 id="饼图">饼图</h3>
<ul>
<li>展示不同类在整体中所占的比重</li>
<li>plt.pie(data, labels, autopct)
<ul>
<li>data - array or sequence of (n,) arrays，数据data</li>
<li>labels - list, optional, default: None，数据标签</li>
<li>autopct - None (default), string, or function, optional，占比计算</li>
</ul>
</li>
</ul>
<pre><code class="language-python">    import matplotlib.pyplot as plt 
    %matplotlib inline
    
    plt.rcParams['font.sans-serif'] = ['SimHei']
    
    labels = ['衣', '食', '住', '行' ]
    data = [2000, 4000, 2000, 1000]
    
    plt.pie(data, labels=labels, autopct='%1.1f%%')
    plt.show()
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://CecilR.github.io/post-images/1569675789800.png" alt=""></figure>
<h3 id="散点图">散点图</h3>
<ul>
<li>验证二维数据的相关性</li>
<li>发现不同类别的二维数据区位图</li>
<li>plt.scatter(X, Y)</li>
</ul>
<pre><code class="language-python">    import matplotlib.pyplot as plt 
    %matplotlib inline
    
    data = [[18.9, 10.4], [21.3, 8.7], [19.5, 11.6], [20.5, 9.7], [19.9, 9.4], [22.3, 10.6]]
    
    X = [item[0] for item in data]
    Y = [item[1] for item in data]
    
    plt.scatter(X, Y)
    plt.rcParams['font.sans-serif'] = ['SimHei']
    plt.title('超市商品价位与销量散点图')
    plt.xlabel('价格（元）')
    plt.ylabel('销量（件）')
    plt.text(19, 11, '牙膏')
    plt.text(20, 9.5, '纸巾')
    plt.text(22, 10.5, '洗衣液')
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://CecilR.github.io/post-images/1569675802145.png" alt=""></figure>
<h3 id="箱线图">箱线图</h3>
<ul>
<li>显示一组数据分散情况的统计图</li>
</ul>
<figure data-type="image" tabindex="6"><img src="https://CecilR.github.io/post-images/1569675815060.png" alt=""></figure>
<ul>
<li>plt.boxplot(X)</li>
</ul>
<pre><code class="language-python">    import matplotlib.pyplot as plt 
    %matplotlib inline
    
    data=[77, 70, 72, 89, 89, 70, 90, 87, 94, 63, 81, 99, 94, 80, 95, 67, 65, 88, 60, 67]
    plt.boxplot(X)
    plt.show()
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://CecilR.github.io/post-images/1569675822534.png" alt=""></figure>
<h3 id="极线图">极线图</h3>
<ul>
<li>极坐标下的数据图，善于表示周期性数据
<ul>
<li>数据点: [极径，角度]</li>
</ul>
</li>
<li>projection = ‘polar’</li>
</ul>
<pre><code class="language-python">    import matplotlib.pyplot as plt 
    %matplotlib inline
    
    r = [1,2,3,4,5] #极径
    theta = [0.0, 1.57, 3.14, 4.71, 6.28] # 角度
    
    ax = plt.subplot(111, projection='polar')
    ax.plot(theta, r)
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://CecilR.github.io/post-images/1569675828215.png" alt=""></figure>
<h3 id="阶梯图">阶梯图</h3>
<ul>
<li>一般用来反映随时间变化的数据</li>
<li>plt.step(X, Y)</li>
</ul>
<pre><code class="language-python">    import matplotlib.pyplot as plt 
    %matplotlib inline
    
    year = range(2005, 2015)
    height = [157, 160, 162, 163, 167, 170, 173, 175, 179, 182]
    
    plt.step(year, height)
</code></pre>
<figure data-type="image" tabindex="9"><img src="https://CecilR.github.io/post-images/1569675839150.png" alt=""></figure>
<hr>
<h2 id="高级图形">高级图形</h2>
<h3 id="图表参数配置">图表参数配置</h3>
<ul>
<li>title: 标题</li>
<li>xlabel, ylabel: x, y轴标签</li>
<li>xticks(x, names): x轴数据标记
<ul>
<li>x - x轴数据</li>
<li>names - list, 数据名</li>
</ul>
</li>
<li>text(x, y, str): 添加文字
<ul>
<li>x,y - 文字坐标</li>
<li>str - 添加的文字</li>
</ul>
</li>
</ul>
<pre><code class="language-python">    import matplotlib.pyplot as plt 
    %matplotlib inline
    
    classes = [1, 2, 3]
    scores = [70, 80, 60]
    names = ['A班', 'B班', 'C班']
    
    plt.bar(classes, scores)
    
    plt.rcParams['font.sans-serif'] = ['SimHei']
    plt.title('成绩柱状图')
    plt.xlabel('班级')
    plt.ylabel('成绩')
    plt.xticks(classes, names)
    for i in range(1,4):
    	plt.text(i, scores[i-1]+1, scores[i-1])
    plt.show()
</code></pre>
<figure data-type="image" tabindex="10"><img src="https://CecilR.github.io/post-images/1569675848380.png" alt=""></figure>
<h3 id="堆积图">堆积图</h3>
<ul>
<li>展示变量分类趋势和总和趋势</li>
<li>plt.bar(x, y, bottom, color, label)  - 叠加绘制
<ul>
<li>x, y - 横纵坐标</li>
<li>bottom - 底部开始值</li>
<li>color， label - 颜色，标签</li>
</ul>
</li>
</ul>
<pre><code class="language-python">    import matplotlib.pyplot as plt 
    %matplotlib inline
    plt.rcParams['font.sans-serif'] = ['SimHei']
    
    n = 5
    number = ['1', '2', '3', '4', '5']
    ch = [72,80,66,77,92]
    math = [62, 92, 72, 75, 88]
    eng = [76, 81, 73, 75, 80]
    chmath = [math[i]+ch[i] for i in range(5)]
    x = range(0,5)
    
    plt.bar(x, ch, color='r', label='语文')
    plt.bar(x, math, bottom=ch, color='g', label='数学')
    plt.bar(x, eng, bottom=chmath, color='b', label='英语')
    plt.ylim(0, 300)
    plt.title('成绩')
    plt.legend(loc='upper right')
    plt.grid(axis='y', color='gray', linestyle=':', linewidth=2)
    plt.xticks(x, number)
    plt.xlabel('学号')
</code></pre>
<figure data-type="image" tabindex="11"><img src="https://CecilR.github.io/post-images/1569675858062.png" alt=""></figure>
<h3 id="分块图">分块图</h3>
<ul>
<li>对比同一变量不同类别的值大小</li>
<li>plt.bar(x, y, width=0.4, fc='r')
<ul>
<li>x,y - 横纵坐标</li>
<li>width - 宽度</li>
<li>fc - 颜色</li>
</ul>
</li>
</ul>
<pre><code class="language-python">    import matplotlib.pyplot as plt 
    %matplotlib inline
    plt.rcParams['font.sans-serif'] = ['SimHei']
    
    names = ['语', '数', '英']
    c1 = [81.4, 83, 87.1] # class 1
    c2 = [85.6, 87.4, 90] # class 2
    c3 = [78, 81.2, 86.1] # class 3
    
    width = 0.4
    
    x1 = [1,3,5]
    x2 = [1.4,3.4,5.4]
    x3 = [1.8,3.8,5.8]
    
    plt.bar(x1, c1, label='class 1', fc='r', width=width)
    plt.bar(x2, c2, label='class 2', fc='g', width=width)
    plt.bar(x3, c3, label='class 3', fc='b', width=width)
    plt.xticks(x2, names)
    plt.legend()
    plt.title('班级成绩图')
    plt.ylabel('成绩')
</code></pre>
<figure data-type="image" tabindex="12"><img src="https://CecilR.github.io/post-images/1569676000583.png" alt=""></figure>
<h3 id="气泡图">气泡图</h3>
<ul>
<li>散点图基础上增加气泡大小来表示另一个变量，感受三个变量的关系</li>
<li>plt.scatter(x, y, s=Z)
<ul>
<li>x, y - 横纵坐标</li>
<li>s - 气泡大小</li>
</ul>
</li>
</ul>
<pre><code class="language-python">    import matplotlib.pyplot as plt 
    %matplotlib inline
    plt.rcParams['font.sans-serif'] = ['SimHei']
    
    data = [[18.9, 10.4, 20], [21.3, 8.7, 40], [19.5, 11.6, 60], [20.5, 9.7, 80], \
    [19.9, 9.4, 60], [22.3, 10.6,40]]
    
    X = [item[0] for item in data]
    Y = [item[1] for item in data]
    Z = [item[2] for item in data]
    
    plt.scatter(X, Y, s=Z)
    plt.xlabel('x')
    plt.ylabel('y')
    plt.slabel('z')
</code></pre>
<figure data-type="image" tabindex="13"><img src="https://CecilR.github.io/post-images/1569675874663.png" alt=""></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python High Performance 读书笔记1]]></title>
        <id>https://CecilR.github.io/post/python-high-performance-du-shu-bi-ji-1</id>
        <link href="https://CecilR.github.io/post/python-high-performance-du-shu-bi-ji-1">
        </link>
        <updated>2019-04-26T06:55:33.000Z</updated>
        <summary type="html"><![CDATA[<p>S1&amp;S2：性能测试&amp;纯粹的python优化</p>
<p>Performance benchmark &amp; pure python optimization</p>
]]></summary>
        <content type="html"><![CDATA[<p>S1&amp;S2：性能测试&amp;纯粹的python优化</p>
<p>Performance benchmark &amp; pure python optimization</p>
<!-- more --> 
<h1 id="s1s2-性能测试-纯粹python内优化">S1&amp;S2 性能测试 &amp; 纯粹python内优化</h1>
<blockquote>
<p>这是关于《Python 高性能》这本书的读书笔记，书本相关代码可在<a href="https://github.com/PacktPublishing/Python-High-Performance-Second-Edition">Repository</a>中下载。</p>
<p>This is my reading notes for <em>Python high performance</em>. Related codes in this book are available in <a href="https://github.com/PacktPublishing/Python-High-Performance-Second-Edition">Repository</a>.</p>
<p>本文为第一章（测试）与第二章（纯粹的python优化）的内容。<br>
This article covers chapter 1 (benchmark) and chapter 2 (optimization in python).</p>
</blockquote>
<h2 id="s1-benchmark">S1 - BenchMark</h2>
<blockquote>
<p>相关文献 <a href="https://nbviewer.jupyter.org/gist/jiffyclub/3062428">Timing</a></p>
</blockquote>
<h3 id="time-timeit-文件级的benchmark">time &amp; timeit - 文件级的benchmark</h3>
<ul>
<li><em>time</em> only in unix bash</li>
</ul>
<pre><code class="language-bash">time simul.py
</code></pre>
<ul>
<li><em>timeit</em> in Ipython, bash, or inside python</li>
</ul>
<pre><code class="language-python"># Ipython
from simul import benchmark
%timeit benchmark()
</code></pre>
<pre><code class="language-bash"># bash
python -m timeit -s 'from simul import benchmark' 'benchmark()'
</code></pre>
<pre><code class="language-python"># python
 import timeit
 result = timeit.repeat('benchmark()', setup='from simul import benchmark', number = 10, repeat = 3)
 print(result)
 result = timeit.timeit('benchmark()', setup='from simul import benchmark', number = 10)
 print(result)
</code></pre>
<h3 id="pytest-pytest-benchmark-文件级的benchmark">pytest &amp; pytest-benchmark - 文件级的benchmark</h3>
<ul>
<li>add <em>benchmark</em> to the funciton args, e.g. test_evolve in test_simul.py</li>
</ul>
<pre><code class="language-bash"># bash
pytest test_simul.py::test_evolve
</code></pre>
<h3 id="cprofile-函数级的benchmark">cProfile - 函数级的benchmark</h3>
<ul>
<li>function analysis in bash</li>
</ul>
<pre><code class="language-bash"># bash
python -m cProfile simul.py
python -m cProfile -s tottime simul.py
python -m cProfile -s tottime -o prof.out simul.py #输出可由status模块解析的文件
</code></pre>
<ul>
<li>function analysis in .py</li>
</ul>
<pre><code class="language-bash"># bash
# code show in cprofile.py
python cprofile.py
</code></pre>
<ul>
<li>function analysis in Ipython</li>
</ul>
<pre><code class="language-python"># Ipython
from simul import benchmark
%prun benchmark()
</code></pre>
<ul>
<li>
<p>analysis resullt</p>
<ol>
<li>ncalls: 函数被调用次数</li>
<li>tottime: 执行花费总时间，不考虑其他函数调用</li>
<li>cumtime: 执行花费总时间，考虑其他函数调用</li>
<li>percall: 单次执行时间，不考虑其他函数调用</li>
<li>filename:lineno: 文件名和响应的行号</li>
</ol>
</li>
<li>
<p>结果可视化 - KCachegrind(with pyprof2calltree)</p>
</li>
</ul>
<pre><code class="language-bash"># Bash
python -m cProfile -o prof.out taylor.py
pyprof2calltree -i prof.out -o prof.calltree
qcachegrind prof.calltree  # ??? Call Graph not usable
</code></pre>
<h3 id="line_profiler-行级的分析">line_profiler - 行级的分析</h3>
<ul>
<li>.py 文件 ＋ 命令行</li>
</ul>
<pre><code class="language-python"># .py文件
@profile
def evolve(self, dt):
    # 代码
</code></pre>
<pre><code class="language-bash">#base
kernprof -l -v simul.py
</code></pre>
<ul>
<li>在Ipython中</li>
</ul>
<pre><code class="language-python"># Ipython
%load_ext line_profiler
from simul import benchmark, ParticleSimulator
%lprun -f ParticleSimulator.evolve benchmark()
</code></pre>
<ul>
<li>
<p>analysis resullt</p>
<ol>
<li>Line # ：行号</li>
<li>Hits : 次数</li>
<li>Time : 执行时间，us</li>
<li>Per Hit : Time/Hits</li>
<li>% Time : 时间百分比</li>
<li>Line Contents : 内容</li>
</ol>
</li>
</ul>
<h3 id="dis-disassemble模块反汇编为字节码">dis - disassemble模块，反汇编为字节码</h3>
<ul>
<li>在命令行中</li>
</ul>
<pre><code class="language-bash"># bash
import dis
from simul import ParticleSimulator
dis.dis(ParticleSimulator.evolve)
</code></pre>
<h3 id="memory_profiler-内存使用情况">memory_profiler - 内存使用情况</h3>
<ul>
<li>在Ipython中使用</li>
</ul>
<pre><code class="language-python"># Ipython
%load_ext memory_profiler
from simul import benchmark_memory, ParticleSimulator
%mprun -f ParticleSimulator.evolve benchmark_memory()
</code></pre>
<ul>
<li><strong>slots</strong> : 通过避免将实例储存在内部字典中，从而节省一些内存，但不能添加没有指定的属性</li>
</ul>
<pre><code class="language-python">class Particle:
    __slots__ = ('x', 'y', 'ang_vel')

    def __init__(self, x, y, ang_vel):
        self.x = x
        self.y = y
        self.ang_vel = ang_vel
</code></pre>
<h2 id="s2-python-optimal">S2 - python optimal</h2>
<h3 id="s21-useful-structures-algorithms">S2.1 useful structures &amp; algorithms</h3>
<h4 id="list-deque-列表和双端队列">list &amp; deque - 列表和双端队列</h4>
<ul>
<li>list
<ul>
<li>访问：O(1)</li>
<li>尾部插入、删除元素(append(1), pop())：O(1)。（如果list所有位置都被占，会触发内存重新分配，此时为O(N)）</li>
<li>头部或中间插入、删除元素(insert(0,1), pop(0))：O(N)</li>
<li>查询：O(N)
<ul>
<li>如果list有序，使用bisect（二分）查找：O(log(N))<pre><code class="language-python">    import bisect
    collection = [1,2,3,4,5,6]
    bisect.bisect(collection, 3) # 返回值为 3

    def index_bisect(a, x):
        i = bisect.bisect(a, x)
        if i != len(a) and a[i] == x:
            return i
        raise ValueError
    
    index_bisect(collection, 3) # 返回值为 2
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>deque(collections.deque)
<ul>
<li>访问：O(N) - (因此不常用)</li>
<li>尾部插入、删除(pop(), append(1))：O(1)</li>
<li>头部插入、删除(popleft(), appendleft(1)): O(1)</li>
</ul>
</li>
</ul>
<h4 id="dict-字典">dict - 字典</h4>
<ul>
<li>访问、插入、删除：O(1)</li>
<li>demo
<ul>
<li>计数独特值的出现次数<pre><code class="language-python">def conter_dict(items):
    counter = {}
    for item in items:
        if item not in counter:
            counter[item] = 0
        else:
            counter[item] += 1
    return counter

from collections import defaultdict
def counter_defaultdict(items):
    counter = defaultdict(int) # 默认初始化为0值，但是效率没有方法一高
    for item in items:
        counter[item] += 1
    return counter

from collections import Counter
counter = Counter(item) # item 为列表，效率最高
</code></pre>
</li>
<li>索引化查找（O(1),但空间复杂度高，灵活性低）<pre><code class="language-python">docs = [&quot;the cat is under the table&quot;,
        &quot;the dog is under the table&quot;,
        &quot;cats and dogs smell roses&quot;,
        &quot;Carla eats an apple&quot;]
matches = [doc for doc in docs if &quot;table&quot; in doc] # O(N)

index = {}
for i, doc in enumerate(docs):
    for word in doc.split():
        if word not in index:
            index[word] = [i]
        else:
            index[word].append(i)

results = index[&quot;table&quot;]
result_documents = [docs[i] for i in results] # O(1)
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="set-集">set - 集</h4>
<ul>
<li>插入、删除、成员资格测试：O(1)</li>
<li>并、交、差集
<ul>
<li>并：s.union(t) - O(S+T)</li>
<li>交：s.intersection(t) - O(min(S,T))</li>
<li>差集：s.difference(t) - O(S)</li>
</ul>
</li>
<li>demo
<ul>
<li>剔除集合中重复元素 - O(N)<pre><code class="language-python">x = list(range(1000))+list(range(500))
x_unique = set(x)
</code></pre>
</li>
<li>布尔查询，索引化查找的可交可并可差版本 - O(1)<pre><code class="language-python">index = {}
for i, doc in enumerate(docs):
    for word in doc.split():
        if word not in index:
            index[word] = {i} # 创建set
        else:
            index[word].append(i)
# 后续可以通过多个关键词的交、并、差操作进行高级化查找
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="heapq-堆">heapq - 堆</h4>
<ul>
<li>用作查找最大最小值
<ul>
<li>有序list用作查找最大最小值时，提取最大值(pop)-O(1); 插入(insert)-O(N);查找(bisect)-O(log(N))</li>
</ul>
</li>
<li>插入和提取最大值 - O(log(N))</li>
<li>demo
<ul>
<li>heapq</li>
</ul>
<pre><code class="language-python">import heapq
collection = [10,3,3,4,5,6]
heapq.heapify(collection)

heapq.heappop(collection) # 返回最小值 3
heapq.heappush(collection, 1) # 压入 1
</code></pre>
<ul>
<li>queue.priorityQueue - 线程和进程安全</li>
</ul>
<pre><code class="language-python">from queue import PriorityQueue

queue = PriorityQueue()
for element in collection:
    que.put(element) # 压入
queue.get() # 返回最小值 3， 若要获得最大值，可以乘以-1

'''将数字关联到一个对象上，（number, object）元组'''
queue1 = PriortyQueue()
queue1.put((3, &quot;priority 3&quot;))
queue1.put((2, &quot;priority 2&quot;))
queue1.put((1, &quot;priority 1&quot;))
queue1.get() # 返回：(1, &quot;priority 1&quot;)
</code></pre>
</li>
</ul>
<h4 id="strings_dict-字典树前缀树">strings_dict - 字典树(前缀树)</h4>
<ul>
<li>用来在列表中查找与前缀匹配的字符串</li>
<li>需要pip安装patricia-trie（进一步可以使用C语言编写的datrie和marisa-trie）</li>
<li>demo<pre><code class="language-python">from random import choice
from string import ascii_uppercase

def random_string(length):
		return ''.join(choice(ascii_uppercase) for i in range(length))

strings = [random_string(32) for i in range(10000)]
matches = [s for s in strings if s.startswith('AA')] # 线性扫描 - O(N)
# %timeit [s for s in strings if s.startswith('AA')]

from patricia import trie # 字典树
strings_dict = {s:0 for s in strings} # 一个所有值为0的字典
strings_trie = trie(**strings_dict) # 初始化为字典树
matches = [list(strings_trie.iter('AA'))] # 使用迭代器查找 - O(S):S为集合中最长的字符串
# %timeit [list(strings_trie.iter('AA'))]
</code></pre>
</li>
</ul>
<h3 id="s22-缓存和memoization">S2.2 缓存和memoization</h3>
<ul>
<li>Memoization：存储并重用以前的函数调用结果 - 动态规划</li>
<li>基于内存的缓存 - functools.lru_cache
<ul>
<li>demo1</li>
</ul>
<pre><code class="language-python">from functools import lru_cache

@lru_cache(max_size = 16)
def sum2(a, b):
    print(&quot;Calculating {} + {}&quot;.format(a, b))
    return a + b

print(sum2(1, 2))
# 输出：
# Calculating 1 + 2
# 3

print(sum2(1,2))
# 输出：
# 3

sum2.cache_info()
# 输出：
# CacheInfo(hits=0, misses=1, maxsize=128, currsize=1)
sum2.cache_clear()
</code></pre>
<ul>
<li>demo2: fibonacci数列</li>
</ul>
<pre><code class="language-python"># 未使用memoization版本
def fibonacci(n): # O(2^N)
    if n &lt; 1:
        return 1
    else:
        return fibonacci(n-1) + fibonacci(n-2)
%timeit fibonacci(20)
# 输出： 5.57ms per loop

# 使用memoization版本 - O(N)
import timeit
setup_code = '''
from functools import lru_cache
from __main__ import fibonacci
finonacci_memoized = lru_cache(maxsize-None)(fibonacci)
'''

results = timeit.repeat('fibonacci_memoized(20)',
                        setup=setup_code,
                        repeat=1000,
                        number=1)
print(&quot;Fibonacci took {:.2f} us&quot;.format(min(results)))
# 输出： Fibonacci took 0.01us
</code></pre>
</li>
<li>基于磁盘的缓存 - joblib(需要pip安装)
<ul>
<li>使用了智能散列算法</li>
<li>demo</li>
</ul>
<pre><code class="language-python">from joblib import Memory
memory = Memory(cachedir='/path/to/cachedir')

@memory.cache
def sum2(a, b):
    return a + b
</code></pre>
</li>
</ul>
<h3 id="s23-推导和生成器">S2.3 推导和生成器</h3>
<ul>
<li>列表、字典推导和生成器的速度比显式循环快
<ul>
<li>demo1 - 列表推导和生成器</li>
</ul>
<pre><code class="language-python">def loop(): # 显式
    res = []
    for i in range(100000):
        res.append(i * i)
    return sum(res)

def comprehension(): # 列表推导
    return sum([i * i for i in range(100000)])

def generator(): # 生成器
    return sum(i * i for i in range(100000))

%timeit loop()
# 100 loops, best of 3: 16.1 ms per loop
%timeit comprehension()
# 100 loops, best of 3: 10.1 ms per loop
%timeit generator()
# 100 loops, best of 3: 12.4 ms per loop
</code></pre>
<ul>
<li>demo2 - 字典推导</li>
</ul>
<pre><code class="language-python">def loop(): # 显式
    res = {}
    for i in range(100000):
        res[i] = i
    return res

def comprehension(): # 字典推导
    return {i: i for i in range(100000)}
%timeit loop()
# 100 loops, best of 3: 13.2 ms per loop
%timeit comprehension()
# 100 loops, best of 3: 12.8 ms per loop
</code></pre>
</li>
<li>结合使用迭代器和filter、map等函数在内存使用方面更加高效
<ul>
<li>demo</li>
</ul>
<pre><code class="language-python">    def map_comprehension(numbers): # numbers - 迭代器
        a = [n * 2 for n in numbers]
        b = [n ** 2 for n in a]
        c = [n ** 0.33 for n in b]
        return max(c)

    def map_normal(numbers):
        a = map(lambda n: n * 2, numbers)
        b = map(lambda n: n ** 2, a)
        c = map(lambda n: n ** 0.33, b)
        return max(c)
    
    %load_ext memory_profiler
    numbers = range(1000000)
    %memit map_comprehension(numbers)
    # peak memory: 166.33 MiB, increment：102.54 MiB
    %memit map_normal(numbers)
    # peak memory: 71.04 MiB, increment：0.00 MiB
</code></pre>
<ul>
<li>注：更多返回迭代器的函数在模块itertools中</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
</feed>